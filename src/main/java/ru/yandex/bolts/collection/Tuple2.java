package ru.yandex.bolts.collection;

import java.io.Serializable;

import ru.yandex.bolts.function.Function;
import ru.yandex.bolts.function.Function2;


public class Tuple2<T1, T2> implements Serializable {
    private static final long serialVersionUID = 3326001902955370713L;

    public final T1 _1;
    public final T2 _2;

    public Tuple2(T1 _1, T2 _2) {
        this._1 = _1;
        this._2 = _2;
    }


    public T1 get1() {
        return _1;
    }


    public T2 get2() {
        return _2;
    }

    public <R> R reduce(Function2<T1, T2, R> bf) {
        return bf.apply(_1, _2);
    }

    public Tuple2<T2, T1> swap() {
        return tuple(_2, _1);
    }

    @SuppressWarnings("unchecked")
    public <T3, T4> Tuple2<T3, T4> uncheckedCast() {
        return (Tuple2<T3, T4>) this;
    }

    @Override
    public boolean equals(Object o) {
        // generated by Idea
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Tuple2<?, ?> tuple2 = (Tuple2<?, ?>) o;

        if (_1 != null ? !_1.equals(tuple2._1) : tuple2._1 != null) return false;
        if (_2 != null ? !_2.equals(tuple2._2) : tuple2._2 != null) return false;

        return true;
    }

    @Override
    public int hashCode() {
        // generated by Idea
        int result = (_1 != null ? _1.hashCode() : 0);
        result = 31 * result + (_2 != null ? _2.hashCode() : 0);
        return result;
    }

    @Override
    public String toString() {
        return "(" + _1 + ", " + _2 + ")";
    }


    public static <A, B> Function2<A, B, Tuple2<A, B>> consF() {
        return Tuple2::tuple;
    }


    public static <A, B> Function<Tuple2<A, B>, A> get1F() {
        return Tuple2::get1;
    }


    public static <A, B> Function<Tuple2<A, B>, B> get2F() {
        return Tuple2::get2;
    }


    public static <A, B> Function<Tuple2<A, B>, Tuple2<B, A>> swapF() {
        return Tuple2::swap;
    }

    public static <A, B, C> Function<Tuple2<A, B>, Tuple2<C, B>> map1F(final Function<A, C> m) {
        return tuple -> tuple(m.apply(tuple._1), tuple._2);
    }

    public static <A, B, C> Function<Tuple2<A, B>, Tuple2<A, C>> map2F(final Function<B, C> m) {
        return tuple -> tuple(tuple._1, m.apply(tuple._2));
    }

    public static <A, B, C> Function<C, Tuple2<A, B>> join(final Function<C, A> fa, final Function<C, B> fb) {
        return c -> Tuple2.tuple(fa.apply(c), fb.apply(c));
    }


    public static <A, B> Tuple2<A, B> tuple(A a, B b) {
        return new Tuple2<>(a, b);
    }

} //~

package ru.yandex.bolts.function.meta;

import ru.yandex.bolts.collection.Option;


/**
 * @author Stepan Koltsov
 */
public class FunctionType {

    public enum ReturnType {
        OBJECT(""),
        BOOLEAN("B"),
        INT("I"),
        VOID("V"),
        ;

        private final String suffix;

        private ReturnType(String suffix) {
            this.suffix = suffix;
        }
    }

    private final int arity;
    private final ReturnType returnType;

    public FunctionType(int arity, ReturnType returnType) {
        if (arity < 0)
            throw new IllegalArgumentException();
        if (returnType == null)
            throw new IllegalArgumentException();

        this.arity = arity;
        this.returnType = returnType;
    }

    public int getArity() {
        return arity;
    }

    public ReturnType getReturnType() {
        return returnType;
    }

    public String simpleClassName() {
        if (arity == 1 && returnType == ReturnType.OBJECT)
            return "Function";
        else
            return "Function" + arity + returnType.suffix;
    }

    public String fullClassName() {
        return "ru.yandex.bolts.function." + simpleClassName();
    }

    public static Option<FunctionType> parseSimpleClassName(String className) {
        if (className.equals("Function"))
            return Option.some(new FunctionType(1, ReturnType.OBJECT));
        else if (className.equals("Function1"))
            return Option.none();

        if (!className.startsWith("Function"))
            return Option.none();

        ReturnType rt;
        if (className.endsWith(ReturnType.BOOLEAN.suffix))
            rt = ReturnType.BOOLEAN;
        else if (className.endsWith(ReturnType.INT.suffix))
            rt = ReturnType.INT;
        else if (className.endsWith(ReturnType.VOID.suffix))
            rt = ReturnType.VOID;
        else
            rt = ReturnType.OBJECT;


        String x = className.substring("Function".length());
        x = x.substring(0, x.length() - rt.suffix.length());

        try {
            int arity = Integer.parseInt(x);
            return Option.some(new FunctionType(arity, rt));
        } catch (NumberFormatException e) {
            return Option.none();
        }
    }

    @Override
    public int hashCode() {
        // generated by Eclipse
        final int prime = 31;
        int result = 1;
        result = prime * result + arity;
        result = prime * result + ((returnType == null) ? 0 : returnType.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        // generated by Eclipse
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        FunctionType other = (FunctionType) obj;
        if (arity != other.arity)
            return false;
        if (returnType == null) {
            if (other.returnType != null)
                return false;
        } else if (!returnType.equals(other.returnType))
            return false;
        return true;
    }

    @Override
    public String toString() {
        return simpleClassName();
    }

} //~
